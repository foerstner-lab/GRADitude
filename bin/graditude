#!/usr/bin/env python3

import argparse
from graditudelib import normalize
from graditudelib import visualizing_kinetics
from graditudelib import k_means
from graditudelib import elbow_curve
from graditudelib import silhouette
from graditudelib import tSNE


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help="commands")


    # Currently done with DESeq2's approach - maybe add further options
    # TODO: add filter for min row sum (and/or min average number in row etc)
    normalize_parser = subparsers.add_parser("normalize")
    normalize_parser.set_defaults(func=normalize_table)
    normalize_parser.add_argument('--feature_count_table', '-c', required=True)
    normalize_parser.add_argument('--feature_count_start_column', default=1)
    normalize_parser.add_argument("--ref_feature_count_table", "-r", required=True)
    normalize_parser.add_argument("--ref_feature_count_start_column", default=1)
    normalize_parser.add_argument("--normalized_table", "-o", required=True)
    normalize_parser.add_argument("--size_factor_table", "-s", default=None)

    # For each fraction generate/write
    # - Histogram 
    # - Max, mix, median, average
    # - all again all correlation (scatter plot, Pearson and Spearman cor. factor) 
    # generate_table_stats_parser = subparsers.add_parser("generate_table_stats")
    # generate_table_stats_parser.set_defaults(func=generate_table_stats)
    # generate_table_stats_parser.add_argument("--feature_count_table", "-c", required=True)
    # generate_table_stats_parser.add_argument("--feature_count_table", "-c", required=True)
    # generate_table_stats_parser.add_argument("--output_file", "-o" required=True)

    plot_kinetics_parser = subparsers.add_parser("plot_kinetics")
    plot_kinetics_parser.set_defaults(func=plot_kinetics)
    plot_kinetics_parser.add_argument("--feature_count_table", "-c", required=True)
    plot_kinetics_parser.add_argument("--gene_name", "-g", required=True)
    plot_kinetics_parser.add_argument('--feature_count_start_column', default=1)
    plot_kinetics_parser.add_argument("--output_plot", "-o", required=True)
    plot_kinetics_parser.add_argument("--output_format", choices=["html", "pdf"],
                                      default="html")

    k_means_clustering_parser = subparsers.add_parser("k_means_clustering")
    k_means_clustering_parser.set_defaults(func=k_means_clustering)
    k_means_clustering_parser.add_argument("--feature_count_table", required=True)
    k_means_clustering_parser.add_argument("--feature_count_start_column" , default=1)
    k_means_clustering_parser.add_argument(
        "--scaling_method", required=True,
        choices=["no_scaling", "to_max", "to_range", "log_10_to_max"])
    k_means_clustering_parser.add_argument("--pseudo_count", type=float, default=0.0)
    k_means_clustering_parser.add_argument("--number_of_clusters", required=True, type=int)
    k_means_clustering_parser.add_argument("--output_file", "-o", required=True)

    k_means_clustering_elbow_parser = subparsers.add_parser("k_means_clustering_elbow")
    k_means_clustering_elbow_parser.set_defaults(func=generate_k_means_clustering_elbow)
    k_means_clustering_elbow_parser.add_argument("--count_table", "-c", required=True)
    k_means_clustering_elbow_parser.add_argument("--min_number_of_clusters", required=True, type=int)
    k_means_clustering_elbow_parser.add_argument("--max_number_of_clusters", required=True, type=int)

    silhouette_parser = subparsers.add_parser("silhouette_analysis")
    silhouette_parser.set_defaults(func=silhouette_analysis)
    silhouette_parser.add_argument("--feature_count_table", required=True)
    silhouette_parser.add_argument("--feature_count_start_column", default=1)
    silhouette_parser.add_argument("--min_number_of_clusters", required=True, type=int)
    silhouette_parser.add_argument("--max_number_of_clusters", required=True, type=int)
    
    # hierachical_clustering_parser = subparsers.add_parser("hierachical_clustering")
    # hierachical_clustering_parser.set_defaults(func=run_hierachical_clustering)
    # hierachical_clustering_parser.add_argument("--feature_count_table", required=True)
    # hierachical_clustering_parser.add_argument("--output_file", "-o", required=True)
    # hierachical_clustering_parser.add_argument(
    #     "--scaling_method", required=True,
    #     choices=["no_scaling", "to_max", "to_range", "log_10_to_max"])
    # hierachical_clustering_parserr.add_argument("--pseudo_count", type=float, default=0.0)
    

    # pca_parser = subparsers.add_parser("pca")
    # pca_parser.set_defaults(func=run_pca)
    # pca_parser.add_argument("--feature_count_table", required=True)
    # pca_parser.add_argument("--output_file", "-o" required=True)
    # pca_parser.add_argument(
    #     "--scaling_method", required=True,
    #     choices=["no_scaling", "to_max", "to_range", "log_10_to_max"])
    # pca_parser.add_argument("--pseudo_count", type=float, default=0.0)

    # Can either be done on the normalized count table or on the table
    # with k-means cluster. In the later case the dots are colorized
    # by the cluster id.
    t_sne_parser = subparsers.add_parser("t_sne")
    t_sne_parser.set_defaults(func=run_t_sne)
    t_sne_parser.add_argument("--feature_count_table", required=True)
    t_sne_parser.add_argument("--feature_count_start_column", default=1)
    t_sne_parser.add_argument("--output_format", choices=["html", "pdf"],
    default="html")
    t_sne_parser.add_argument("--output_file", "-o", required=True)
    t_sne_parser.add_argument(
        "--scaling_method", required=True,
        choices=["no_scaling", "to_max", "to_range", "log_10_to_max"])
    t_sne_parser.add_argument("--pseudo_count", type=float, default=0.0)

    
    # version_parser = subparsers.add_parser("version")
    # version_parser.set_defaults(func=show_version)

    # This is nice-to-have but not essential!
    # This subcommand will help to select rows and columns to build a
    # defined count table. It will also help to translate attribute
    # column into other columns (e.g. with gene names)
    # rearrange_count_table_parser = subparsers.add_parser("rearrange_count_table")

    args = parser.parse_args()
    if "func" in dir(args):
        args.func(args)
    else:
        parser.print_help()


def normalize_table(args):
    normalize.normalized_count_table(
        args.feature_count_table, args.feature_count_start_column,
        args.ref_feature_count_table, args.ref_feature_count_start_column,
        args.normalized_table, args.size_factor_table)


def plot_kinetics(args):
    visualizing_kinetics.plot_kinetics(
        args.feature_count_table, args.gene_name, args.feature_count_start_column,
        args.output_format)


def k_means_clustering(args):
    k_means.generate_k_means_clustering(args.feature_count_table,
                                        args.number_of_clusters,
                                        args.feature_count_start_column,
                                        args.output_file,
                                        args.scaling_method, args.pseudo_count)


def generate_k_means_clustering_elbow(args):
    elbow_curve.k_means_clustering_elbow(args.feature_count_table,
                                         args.min_number_of_clusters,
                                         args.max_number_of_clusters,
                                         args.output_plot)


def silhouette_analysis(args):
    silhouette.silhouette_analysis(args.feature_count_table,
                                   args.feature_count_start_column,
                                   args.min_number_of_clusters,
                                   args.max_number_of_clusters)


def run_t_sne(args):
    tSNE.t_sne_analysis(args.feature_count_table,
                        args.feature_count_start_column,
                        args.pseudo_count,
                        args.scaling_method,
                        args.output_format)


main()
